# -*- coding: utf-8 -*-
"""Numpy Assignment by Maroofa Roohan

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wv82DF4oBeUGusNenBDerJ3Z_Z-j0vzR
"""

#Numpy  Assignment

#Theoretical questions:

# 1. **Purpose and Advantages of NumPy in Scientific Computing and Data Analysis**
#- **Purpose**: NumPy is designed for numerical and matrix operations, providing support for large, multi-dimensional arrays and matrices.
#- **Advantages**:
#- **Efficient computations**: NumPy is implemented in C, providing faster performance for mathematical operations compared to Python's built-in lists.
#- **Vectorization**: Eliminates the need for loops, making code faster and easier to write.
#- **Extensive functions**: Provides a wide range of mathematical, statistical, and linear algebra operations.
#- **Enhancement of Python**: By providing these capabilities, NumPy turns Python into a more powerful tool for scientific computing, allowing it to handle large datasets and complex operations efficiently.

# 2. **np.mean() vs np.average() in NumPy**
#- **np.mean()**: Calculates the arithmetic mean along a specified axis or the entire array.
#np.mean(array)
#- **np.average()**: Calculates the weighted average if weights are provided, otherwise, it behaves like `mean()`.
#   np.average(array, weights=weights_array)
#  - **Usage**: Use `np.average()` when you need weighted averages; otherwise, `np.mean()` suffices for simple means.

# 3. **Methods for Reversing a NumPy Array**
# - **1D Array**: Use slicing to reverse the elements
#     array[::-1]
# - **2D Array**:
# - Reverse along rows (`flipud`):
#  np.flipud(array)
#- Reverse along columns (`fliplr`):
 #np.fliplr(array)

# 4. **Determining Data Type in a NumPy Array**
#  **Method**: Use `dtype` attribute
#   array.dtype
#  **Importance of Data Types**:
 #  Memory efficiency: Choosing an appropriate data type (e.g., `int8`, `int32`) reduces memory usage.
# Performance: Fixed data types allow NumPy to perform faster operations than Python’s dynamically typed lists.

# 5. **ndarrays in NumPy**
#- **Definition**: An `ndarray` is a multi-dimensional array object in NumPy that supports element-wise operations.
# - **Key Features**:
#  - Fixed size and type.
# - Supports mathematical and statistical operations.
#- Efficient storage and faster computations.
#- **Difference from Python Lists**:
# - Lists are more flexible but slower due to dynamic typing.
#- `ndarrays` are optimized for numerical operations with homogeneous data types.

# 6. **Performance Benefits of NumPy Arrays over Python Lists**
#- **Memory Efficiency**: NumPy arrays store elements more compactly, reducing memory overhead.
#- **Speed**: NumPy arrays are implemented in C, which allows faster execution of numerical operations compared to Python’s native lists.
#- **Vectorization**: NumPy operations are vectorized, eliminating the need for loops and speeding up execution.

# 7. **vstack() vs hstack() in NumPy**
#- **vstack()**: Vertically stacks arrays (row-wise).
#     np.vstack([array1, array2])
#   - **hstack()**: Horizontally stacks arrays (column-wise).
#     np.hstack([array1, array2])

# 8. **fliplr() vs flipud() in NumPy**
#- **fliplr()**: Flips an array left to right (reverses the order of columns).
#     np.fliplr(array)

 #- **flipud()**: Flips an array up and down (reverses the order of rows).
#     np.flipud(array)

# 9. **Functionality of array_split() in NumPy**
#- **array_split()**: Splits an array into sub-arrays. It can handle uneven splits by distributing elements across sub-arrays as evenly as possible.
     #np.array_split(array, 3)  # Splits into 3 parts


# 10. **Vectorization and Broadcasting in NumPy**
# - **Vectorization**: Allows element-wise operations on entire arrays without the need for loops, making code cleaner and more efficient.
# - **Broadcasting**: Automatically expands smaller arrays to match the shape of larger ones during operations.
#  Example:

    # array + scalar  # The scalar is broadcast to match the shape of the array

   # **Contribution**: These techniques optimize memory and speed up array operations, especially in large datasets.

#Practical questions:

#1. Create a 3x3 NumPy Array with Random Integers and Interchange Rows and Columns

import numpy as np

array = np.random.randint(1, 101, size=(3, 3))
print("Original Array:\n", array)

# Interchange rows and columns using transpose
transposed_array = array.T
print("Transposed Array:\n", transposed_array)

#2. Generate a 1D NumPy Array and Reshape it into a 2x5 and then a 5x2 Array
array = np.arange(1, 11)  # 1D array with 10 elements
array_2x5 = array.reshape(2, 5)  # Reshaped into 2x5
array_5x2 = array.reshape(5, 2)  # Reshaped into 5x2

print("1D Array:", array)
print("2x5 Array:\n", array_2x5)
print("5x2 Array:\n", array_5x2)

#3. Create a 4x4 NumPy Array with Random Float Values and Add a Border of Zeros

array = np.random.rand(4, 4)  # 4x4 array with random floats
bordered_array = np.pad(array, pad_width=1, mode='constant', constant_values=0)  # Add a zero border

print("4x4 Array:\n", array)
print("6x6 Array with Border:\n", bordered_array)

#4. Create an Array of Integers from 10 to 60 with a Step of 5
array = np.arange(10, 61, 5)
print("Array of Integers from 10 to 60:", array)

#5. Create a NumPy Array of Strings and Apply Different Case Transformations

array = np.array(['python', 'numpy', 'pandas'])

upper_case = np.char.upper(array)
lower_case = np.char.lower(array)
title_case = np.char.title(array)

print("Uppercase:", upper_case)
print("Lowercase:", lower_case)
print("Title Case:", title_case)

#6. Generate a NumPy Array of Words and Insert a Space Between Each Charactere
words = np.array(['hello', 'world'])
spaced_words = np.char.join(' ', words)

print("Original Words:", words)
print("Words with Spaces Between Characters:", spaced_words)

#7. Element-wise Addition, Subtraction, Multiplication, and Division of Two 2D Arrays
array1 = np.random.randint(1, 11, size=(2, 2))  # 2x2 array
array2 = np.random.randint(1, 11, size=(2, 2))  # 2x2 array

addition = array1 + array2
subtraction = array1 - array2
multiplication = array1 * array2
division = array1 / array2

print("Array 1:\n", array1)
print("Array 2:\n", array2)
print("Addition:\n", addition)
print("Subtraction:\n", subtraction)
print("Multiplication:\n", multiplication)
print("Division:\n", division)

#8. Create a 5x5 Identity Matrix and Extract Its Diagonal Elements

identity_matrix = np.eye(5)  # 5x5 identity matrix
diagonal_elements = np.diag(identity_matrix)  # Extract diagonal elements

print("5x5 Identity Matrix:\n", identity_matrix)
print("Diagonal Elements:", diagonal_elements)

#9. Find Prime Numbers in a NumPy Array of 100 Random Integers

def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

array = np.random.randint(0, 1001, size=100)
primes = np.array([num for num in array if is_prime(num)])

print("Original Array:", array)
print("Prime Numbers:", primes)

#10. Create a NumPy Array of Daily Temperatures for a Month and Calculate Weekly Averages
import numpy as np

# Generate random daily temperatures for 30 days
temperatures = np.random.randint(20, 40, size=30)

# Split the array into 4 full weeks (7 days each) and the remaining days
weeks = np.array_split(temperatures, 5)  # Split into 5 weeks (4 weeks of 7 days, 1 week of 2 days)

# Calculate the weekly averages
weekly_avg = [week.mean() for week in weeks]

print("Daily Temperatures:", temperatures)
print("Weekly Averages:", weekly_avg)

